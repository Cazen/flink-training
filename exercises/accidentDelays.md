---
layout: page
title: DataStream API - Accident Delays
permalink: /exercises/accidentDelays.html
---

The task of the "Accident Delays" exercise is to identify taxi rides that might have been delayed due to traffic accidents. For this purpose, two data streams, a stream of taxi ride records and a stream of accident reports, are connected. Similar to the start and end events of taxi rides, the emergence and clearance of accidents is reported. For simplicity, we assume that the taxi rides travel on the direct connection between their start and end location. 
The `GeoUtils` class provides a method `GeoUtils.mapToGridCellsOnWay()` which returns a list of all grid cell ids on the direct connection of two locations. The goal of the exercise is to send one notification for each grid cell on which a ride might have been delayed due to an accident, while the ride was happening (accident was not cleared during start and end of the ride).

### Input Data

The first input data stream of this exercise is a stream of `TaxiRide` records generated by the [Taxi Stream generator]({{ site.baseurl }}/exercises/taxiData.html) filtered by the New York City area filter of the [Taxi Ride Cleansing exercise]({{ site.baseurl }}/exercises/rideCleansing.html) (reuse the FilterFunction of the Taxi Ride Cleansing exercise).

The second input data stream is a `DataStream<Accident>` which randomly reports the emergence and clearance of accidents within the New York City area. Two records are emitted for each accident, an emergence and a clearance record. Both record types can be distinguished by the `Accidents.isCleared` field which is set to `true` if the accident was cleared.

The generator is used as follows:

{% highlight java %}
// get an ExecutionEnvironment
StreamExecutionEnvironment env = 
  StreamExecutionEnvironment.getExecutionEnvironment();

// add an accidents generator
DataStream<Accident> accidents = env
	.addSource(new AccidentGenerator(servingSpeedFactor);
{% endhighlight %}

### Expected Output

The result of the exercise should be a `DataStream<Tuple2<Integer, TaxiRide>>` where the first field is the id of the cell in which an accident happened while the ride (second field) was passing.

The result stream can be written to standard out, Kafka, or to a file.

### Implementation Hints

#### Program Structure

The Accident Delays exercises is based on two data streams, the taxi rides stream and the accident reports stream. Both streams need to be connected. Since we want to match rides with accidents that happened on their way, we need to co-locate records of both streams based on cell grid ids. When both streams are partitioned by cell grid id, we can use a [Co-Operator](https://ci.apache.org/projects/flink/flink-docs-release-0.9/apis/streaming_guide.html#co-operators) to process records of both streams in the same operator. Finally, the result can be emitted to any data sink.

#### Mapping Taxi Rides and Accidents to Grid Cells

The `GeoUtils` class provides methods to map a single location (`GeoUtils.mapToGridCell`) or the path between two location (`GeoUtils.mapToGridCellsOnWay`) to grid cell ids. For accidents a `MapFunction` can be used to map an accident to its cell grid id. For taxi rides a `FlatMapFunction` must be used to map a taxi ride to each grid cell that is passed on the way from its departure to destination.

#### Partitioning Taxi Rides and Accidents

Taxi rides and accident reports must be co-partitioned by event location, i.e., partitioned on the same attribute (grid cell id). You can use `DataStream.groupBy()` to partition data streams.

#### Identifying Delayed Taxi Rides

If both data streams are co-partitioned, you can connect them and apply a [CoFlatMapFunction](https://ci.apache.org/projects/flink/flink-docs-release-0.9/apis/streaming_guide.html#co-operators) to process records of both streams by calling `DataStream.connect(DataStream).flatMap(CoFlatMapFunction)`. The `CoFlatMapFunction` defines two methods, one for processing taxi ride records and one for accident records. When an accident record arrives, we need to distinguish between emergence and clearance records. For emergence records we send out an record for each ride that have been observed for this grid cell (and forget these rides) and remember the accident. For a clearance record, we forget the accident. When a taxi ride start record arrives, we send out a record if we find an accident for its cell id. If there was no accident reported, we remember the taxi ride. When a taxi ride end record arrives, we forget the taxi ride if it is remembered.

**Note:** Partitioning does not mean that a `CoFlatMapFunction` instance only received records with a unique grid cell id, but it ensures that all records with the same grid cell id are processed by the same function instance. This means, that your function needs to handle records with different grid cell ids.

### Reference Solution

Reference solutions are available at GitHub:

- Java: [AccidentDelays.java](https://github.com/dataArtisans/flink-training/blob/master/flink-exercises/src/main/java/com/dataArtisans/flinkTraining/exercises/dataStreamJava/accidentDelays/AccidentDelays.java)
