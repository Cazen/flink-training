---
layout: page
title: DataStream API - Accident Delays
permalink: /exercises/accidentDelays.html
---

The task of the "Accident Delays" exercise is to identify taxi rides that might have been delayed due to traffic accidents. For this purpose, two data streams, a stream of taxi ride records and a stream of accident reports, are connected. Similar to the start and end events of taxi rides, the emergence and clearance of accidents is reported. For simplicity, we assume that the taxi rides travel on the direct connection between their start and end location. 
The `GeoUtils` class provides a method `GeoUtils.mapToGridCellsOnWay()` which returns a list of all grid cell ids on the direct path between two locations. The goal of the exercise is to send one notification for each grid cell on which a ride might have been delayed due to an accident. All accidents that happened before or during a ride should be considered except those that were cleared before the ride started.

### Input Data

The first input data stream of this exercise is a `DataStream<TaxiRide>` generated by the [Taxi Stream generator]({{ site.baseurl }}/exercises/taxiData.html) filtered by the New York City area filter of the [Taxi Ride Cleansing exercise]({{ site.baseurl }}/exercises/rideCleansing.html) (reuse the FilterFunction of the Taxi Ride Cleansing exercise).

The second input data stream is a `DataStream<Accident>` which randomly reports the emergence and clearance of accidents within the New York City area. For each accident two records are emitted, an emergence and a clearance record. Both record types can be distinguished by the `Accidents.isCleared` field which is set to `true` if the accident was cleared.

The generator is used as follows:

{% highlight java %}
// get an ExecutionEnvironment
StreamExecutionEnvironment env = 
  StreamExecutionEnvironment.getExecutionEnvironment();

// add an accidents generator
DataStream<Accident> accidents = env
	.addSource(new AccidentGenerator(servingSpeedFactor);
{% endhighlight %}

### Expected Output

The result of the exercise should be a `DataStream<Tuple2<Integer, TaxiRide>>` where the first field is the id of the grid cell in which an accident happened while the ride (second field) was passing.

The result stream can be written to standard out, Kafka, or to a file.

### Implementation Hints

<div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingOne">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
Program Structure
        </a>
      </h4>
    </div>
    <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
      <div class="panel-body" markdown="span">
The Accident Delays exercises is based on two data streams, the taxi rides stream and the accident reports stream. Both streams need to be connected. Since we want to match rides with accidents that happened on their way, we need to co-locate records of both streams based on cell grid ids. When both streams are partitioned by cell grid id, we can use a [Co-Operator](https://ci.apache.org/projects/flink/flink-docs-release-0.9/apis/streaming_guide.html#co-operators) to process records of both streams in the same operator. Finally, the result can be emitted to any data sink.
      </div>
    </div>
  </div>
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingTwo">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
Mapping Taxi Rides and Accidents to Grid Cells
        </a>
      </h4>
    </div>
    <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
      <div class="panel-body" markdown="span">
The `GeoUtils` class provides methods to map a single location (`GeoUtils.mapToGridCell`) or the path between two location (`GeoUtils.mapToGridCellsOnWay`) to grid cell ids. For accidents a `MapFunction` can be used to map an accident to its cell grid id. For taxi rides a `FlatMapFunction` must be used because for each grid cell that is passed by a ride on its way a record needs to be emitted.
      </div>
    </div>
  </div>
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingThree">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
Partitioning Taxi Rides and Accidents
        </a>
      </h4>
    </div>
    <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
      <div class="panel-body" markdown="span">
Taxi rides and accident reports must be co-partitioned by event location, i.e., partitioned on the same attribute (grid cell id). You can use `DataStream.groupBy()` to partition data streams.
      </div>
    </div>
  </div>
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingFour">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseFour" aria-expanded="false" aria-controls="collapseFour">
Identifying Delayed Taxi Rides
        </a>
      </h4>
    </div>
    <div id="collapseFour" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingFour">
      <div class="panel-body" markdown="span">
Once both data streams are co-partitioned, you can connect them and apply a [CoFlatMapFunction](https://ci.apache.org/projects/flink/flink-docs-release-0.9/apis/streaming_guide.html#co-operators) to process records of both streams by calling `DataStream.connect(DataStream).flatMap(CoFlatMapFunction)`. The `CoFlatMapFunction` defines two methods, one for processing taxi ride records and one for accident records. When an accident record arrives, we need to distinguish between emergence and clearance records. For emergence records we send out an record for each ride that has been observed on this grid cell (and forget this rides) and remember the accident. For a clearance record, we forget the accident. When a taxi ride start record arrives, we send out a record if we find an accident for its cell id. If there was no accident reported, we remember the taxi ride. When a taxi ride end record arrives, we forget the taxi ride if it is remembered.
<br>
**Note:** Partitioning does not mean that a `CoFlatMapFunction` instance only received records with a unique grid cell id, but it ensures that all records with the same grid cell id are processed by the same function instance. This means, that your function needs to handle records with different grid cell ids.
      </div>
    </div>
  </div>
</div>

### Reference Solution

Reference solutions are available at GitHub:

- Java: [AccidentDelays.java](https://github.com/dataArtisans/flink-training-exercises/blob/master/src/main/java/com/dataArtisans/flinkTraining/exercises/dataStreamJava/accidentDelays/AccidentDelays.java)
- Scala: [AccidentDelays.scala](https://github.com/dataArtisans/flink-training-exercises/blob/master/src/main/scala/com/dataArtisans/flinkTraining/exercises/dataStreamScala/accidentDelays/AccidentDelays.scala)
